# -*- coding: utf-8 -*-
"""Fibrin sturcture plasma thrombin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N97gmV8XPSjpD-jh3DYeMrrDJhs1iO1a
"""

import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt

# Create a DataFrame with your updated data
data = {
    "Fibrinogen Concentration": [2.7, 2.7, 2.7, 2.7],
    "Thrombin Concentration": [0.1, 0.25, 0.5, 1],
    "Average Diameter": [162.6, 142.1, 83.8, 73],
    "Average Pore size": [9.2, 6.1, 5.7, 5.1],
    "Average % Density": [20.6, 27.9, 27.3, 34.2],
    "Average Fiber Length": [15.5, 11.7, 10, 9.5],
    "Lag time": [113, 24, 13, 0],
    "Rate of Formation": [2.3, 2.1, 1.6, 1.5],
    "Max Turbidity": [2.31, 3.02, 2.83, 3.51]
}

df = pd.DataFrame(data)

# Define the independent variables (Fibrinogen and Thrombin concentrations)
independent_variables = ["Fibrinogen Concentration", "Thrombin Concentration"]

# Iterate through the dependent variables
dependent_variables = df.columns[2:]

for dependent_variable in dependent_variables:
    y = df[dependent_variable]
    X = df[independent_variables]
    X = sm.add_constant(X)  # Add a constant term (intercept)

    model = sm.OLS(y, X).fit()

    # Get the regression parameters
    params = model.params

    # Calculate R-squared value
    r_squared = model.rsquared

    # Generate predicted values
    y_pred = X.dot(params)

    # Create the actual vs. experimental plot
    plt.figure(figsize=(10, 6))
    plt.scatter(y, y_pred)
    plt.xlabel(f"Actual {dependent_variable}")
    plt.ylabel(f"Experimental {dependent_variable}")
    plt.title(f"Actual vs. Experimental {dependent_variable}")

    # Construct the equation (including intercept)
    equation = f"{dependent_variable} = {params[0]:.2f} + "

    for i, var in enumerate(independent_variables):
        equation += f"{params[var]:.2f} * {var}"

        if i < len(independent_variables) - 1:
            equation += " + "

    r_squared_text = f"R-squared = {r_squared:.4f}"
    plt.text(0.1, 0.9, equation, transform=plt.gca().transAxes, fontsize=12)
    plt.text(0.1, 0.8, r_squared_text, transform=plt.gca().transAxes, fontsize=12)

    # Show the plot
    plt.show()

import numpy as np
import pandas as pd
import statsmodels.api as sm

# Create a DataFrame with your updated data
data = {
    "Fibrinogen Concentration": [2.7, 2.7, 2.7, 2.7],
    "Thrombin Concentration": [0.1, 0.25, 0.5, 1],
    "Average Diameter": [162.6, 142.1, 83.8, 73],
    "Average Pore size": [9.2, 6.1, 5.7, 5.1],
    "Average % Density": [20.6, 27.9, 27.3, 34.2],
    "Average Fiber Length": [15.5, 11.7, 10, 9.5],
    "Lag time": [113, 24, 13, 0],
    "Rate of Formation": [2.3, 2.1, 1.6, 1.5],
    "Max Turbidity": [2.31, 3.02, 2.83, 3.51]
}

df = pd.DataFrame(data)

# Define the independent variables (Fibrinogen and Thrombin concentrations)
independent_variables = ["Fibrinogen Concentration", "Thrombin Concentration"]

# Iterate through the dependent variables
dependent_variables = df.columns[2:]

for dependent_variable in dependent_variables:
    y = df[dependent_variable]
    X = df[independent_variables]
    X = sm.add_constant(X)  # Add a constant term (intercept)

    model = sm.OLS(y, X).fit()

    # Get the regression parameters
    params = model.params

    # Calculate R-squared value
    r_squared = model.rsquared

    # Construct the equation (including intercept)
    equation = f"{dependent_variable} = {params[0]:.2f} + "

    for i, var in enumerate(independent_variables):
        equation += f"{params[var]:.2f} * {var}"

        if i < len(independent_variables) - 1:
            equation += " + "

    # Print the equation and R-squared value
    print(f"Equation for {dependent_variable}:")
    print(equation)
    print(f"R-squared for {dependent_variable}: {r_squared:.4f}")
    print()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# Define the non-linear models for each parameter
def non_linear_model(x, a, b, c):
    return a * np.exp(b * x) * np.exp(c * x)

# Create a DataFrame with your updated data
data = {
    "Fibrinogen Concentration": [2.7, 2.7, 2.7, 2.7],
    "Thrombin Concentration": [0.1, 0.25, 0.5, 1],
    "Average Diameter": [162.6, 142.1, 83.8, 73],
    "Average Pore Size": [9.2, 6.1, 5.7, 5.1],
    "Average % Density": [20.6, 27.9, 27.3, 34.2],
    "Average Fiber Length": [15.5, 11.7, 10, 9.5],
    "Lag Time": [113, 24, 13, 0],
    "Rate of Formation": [2.3, 2.1, 1.6, 1.5],
    "Max Turbidity": [2.31, 3.02, 2.83, 3.51]
}

df = pd.DataFrame(data)

# Define the independent variables (Fibrinogen and Thrombin concentrations)
x_fibrinogen = df["Fibrinogen Concentration"].values
x_thrombin = df["Thrombin Concentration"].values

# Iterate through the parameters and perform non-linear regression for each
parameters = df.columns[2:]

for parameter in parameters:
    y_data = df[parameter].values

    # Perform non-linear regression
    params, _ = curve_fit(non_linear_model, x_fibrinogen, y_data)

    # Extract the estimated parameters
    a, b, c = params

    # Generate predicted values based on the estimated parameters
    predicted = [non_linear_model(x, a, b, c) for x in x_fibrinogen]

    # Calculate R-squared value
    residuals = y_data - predicted
    ss_residuals = np.sum(residuals**2)
    ss_total = np.sum((y_data - np.mean(y_data))**2)
    r_squared = 1 - (ss_residuals / ss_total)

    # Plot actual vs. predicted values
    plt.figure(figsize=(10, 6))
    plt.scatter(y_data, predicted, edgecolors='b')
    plt.xlabel(f"Actual {parameter}")
    plt.ylabel(f"Predicted {parameter}")
    plt.title(f"Actual vs. Predicted {parameter}")

    # Show the equation and R-squared value on the plot
    equation = f"{parameter} = {a:.2f} * exp({b:.2f} * Fibrinogen) * exp({c:.2f} * Thrombin)"
    r_squared_text = f"R-squared = {r_squared:.4f}"
    plt.text(0.1, 0.9, equation, transform=plt.gca().transAxes, fontsize=12)
    plt.text(0.1, 0.8, r_squared_text, transform=plt.gca().transAxes, fontsize=12)

    # Show the plot
    plt.show()

