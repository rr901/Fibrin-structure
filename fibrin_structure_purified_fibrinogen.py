# -*- coding: utf-8 -*-
"""Fibrin Structure Purified Fibrinogen.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qaNSmY0UVU3cidx4_UuwVSSML_cItqhv
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Create a DataFrame with your updated data
data = {
    "Fibrinogen Concentration": [1, 2.7, 5, 10, 2.7, 2.7, 2.7, 2.7],
    "Thrombin Concentration": [0.1, 0.1, 0.1, 0.1, 0.1, 0.25, 0.5, 1],
    "Average Diameter": [178.1, 217.6, 228.2, 284.2, 217.4, 182.6, 168.5, 128.7],
    "Average Pore Size": [8.9, 5.8, 3.1, 1.9, 5.8, 5, 3.2, 2.5],
    "Average % Density": [11.9, 23.7, 44.7, 44.4, 23.7, 29.6, 25.4, 33.2],
    "Average Fiber Length": [9.1, 7.7, 4, 3.3, 7.7, 6.7, 5.6, 3.9],
    "Lag Time": [140, 155, 175, 210, 105, 75, 30, 0],
    "Rate of Formation": [3.4, 6.88, 8.2, 10.2, 9.9, 14.1, 24.5, 33.3],
    "Max Turbidity": [1.85, 5.24, 7.85, 9.35, 5.86, 5.2, 5.13, 4.47]
}

df = pd.DataFrame(data)

# Define the independent variables (Fibrinogen and Thrombin concentrations)
X = df[["Fibrinogen Concentration", "Thrombin Concentration"]]

# Iterate through the parameters and perform linear regression for each
parameters = df.columns[2:]

for parameter in parameters:
    y = df[parameter]

    # Perform linear regression
    model = LinearRegression()
    model.fit(X, y)
    y_pred = model.predict(X)

    # Calculate R-squared value
    r_squared = model.score(X, y)

    # Plot actual vs. expected values
    plt.figure(figsize=(10, 6))
    plt.scatter(y, y_pred)
    plt.xlabel(f"Actual {parameter}")
    plt.ylabel(f"Expected {parameter}")
    plt.title(f"Actual vs. Expected {parameter}")

    # Show the equation and R-squared value on the plot
    equation = f"{parameter} = {model.intercept_:.2f} + {model.coef_[0]:.2f} * Fibrinogen + {model.coef_[1]:.2f} * Thrombin"
    r_squared_text = f"R-squared = {r_squared:.4f}"
    plt.text(0.1, 0.9, equation, transform=plt.gca().transAxes, fontsize=12)
    plt.text(0.1, 0.8, r_squared_text, transform=plt.gca().transAxes, fontsize=12)

    # Show the plot
    plt.show()

import numpy as np
import pandas as pd
import statsmodels.api as sm

# Create a DataFrame with your updated data
data = {
    "Fibrinogen Concentration": [1, 2.7, 5, 10, 2.7, 2.7, 2.7, 2.7],
    "Thrombin Concentration": [0.1, 0.1, 0.1, 0.1, 0.1, 0.25, 0.5, 1],
    "Average Diameter": [178.1, 217.6, 228.2, 284.2, 217.4, 182.6, 168.5, 128.7],
    "Average Pore Size": [8.9, 5.8, 3.1, 1.9, 5.8, 5, 3.2, 2.5],
    "Average % Density": [11.9, 23.7, 44.7, 44.4, 23.7, 29.6, 25.4, 33.2],
    "Average Fiber Length": [9.1, 7.7, 4, 3.3, 7.7, 6.7, 5.6, 3.9],
    "Lag Time": [140, 155, 175, 210, 105, 75, 30, 0],
    "Rate of Formation": [3.4, 6.88, 8.2, 10.2, 9.9, 14.1, 24.5, 33.3],
    "Max Turbidity": [1.85, 5.24, 7.85, 9.35, 5.86, 5.2, 5.13, 4.47]
}

df = pd.DataFrame(data)

# Define the independent variables (Fibrinogen and Thrombin concentrations)
X = df[["Fibrinogen Concentration", "Thrombin Concentration"]]
X = sm.add_constant(X)  # Add a constant term (intercept)

# Iterate through the parameters and perform linear regression for each
parameters = df.columns[2:]

for parameter in parameters:
    y = df[parameter]
    model = sm.OLS(y, X).fit()

    # Extract coefficients and R-squared value
    intercept = model.params[0]
    coef_fibrinogen = model.params[1]
    coef_thrombin = model.params[2]
    r_squared = model.rsquared

    # Create the equation string
    equation = f"{parameter} = {intercept:.2f} + {coef_fibrinogen:.2f} * Fibrinogen + {coef_thrombin:.2f} * Thrombin"

    # Print the equation and R-squared value
    print(f"{parameter}:")
    print(equation)
    print(f"R-squared: {r_squared}\n")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# Define the non-linear models for each parameter
def non_linear_model(x, a, b, c):
    return a * np.exp(b * x) * np.exp(c * x)

# Create a DataFrame with your updated data
data = {
    "Fibrinogen Concentration": [1, 2.7, 5, 10, 2.7, 2.7, 2.7, 2.7],
    "Thrombin Concentration": [0.1, 0.1, 0.1, 0.1, 0.1, 0.25, 0.5, 1],
    "Average Diameter": [178.1, 217.6, 228.2, 284.2, 217.4, 182.6, 168.5, 128.7],
    "Average Pore Size": [8.9, 5.8, 3.1, 1.9, 5.8, 5, 3.2, 2.5],
    "Average % Density": [11.9, 23.7, 44.7, 44.4, 23.7, 29.6, 25.4, 33.2],
    "Average Fiber Length": [9.1, 7.7, 4, 3.3, 7.7, 6.7, 5.6, 3.9],
    "Lag Time": [140, 155, 175, 210, 105, 75, 30, 0],
    "Rate of Formation": [3.4, 6.88, 8.2, 10.2, 9.9, 14.1, 24.5, 33.3],
    "Max Turbidity": [1.85, 5.24, 7.85, 9.35, 5.86, 5.2, 5.13, 4.47]
}

df = pd.DataFrame(data)

# Define the independent variables (Fibrinogen and Thrombin concentrations)
x_fibrinogen = df["Fibrinogen Concentration"].values
x_thrombin = df["Thrombin Concentration"].values

# Iterate through the parameters and perform non-linear regression for each
parameters = df.columns[2:]

for parameter in parameters:
    y_data = df[parameter].values

    # Perform non-linear regression
    params, _ = curve_fit(non_linear_model, x_fibrinogen, y_data)

    # Extract the estimated parameters
    a, b, c = params

    # Generate predicted values based on the estimated parameters
    predicted = [non_linear_model(x, a, b, c) for x in x_fibrinogen]

    # Calculate R-squared value
    residuals = y_data - predicted
    ss_residuals = np.sum(residuals**2)
    ss_total = np.sum((y_data - np.mean(y_data))**2)
    r_squared = 1 - (ss_residuals / ss_total)

    # Plot actual vs. predicted values
    plt.figure(figsize=(10, 6))
    plt.scatter(y_data, predicted, edgecolors='b')
    plt.xlabel(f"Actual {parameter}")
    plt.ylabel(f"Predicted {parameter}")
    plt.title(f"Actual vs. Predicted {parameter}")

    # Show the equation and R-squared value on the plot
    equation = f"{parameter} = {a:.2f} * exp({b:.2f} * Fibrinogen) * exp({c:.2f} * Thrombin)"
    r_squared_text = f"R-squared = {r_squared:.4f}"
    plt.text(0.1, 0.9, equation, transform=plt.gca().transAxes, fontsize=12)
    plt.text(0.1, 0.8, r_squared_text, transform=plt.gca().transAxes, fontsize=12)

    # Show the plot
    plt.show()

import numpy as np
import pandas as pd
from scipy.optimize import curve_fit

# Define the non-linear models for each parameter
def non_linear_model(x, a, b, c):
    return a * np.exp(b * x) * np.exp(c * x)

# Create a DataFrame with your updated data
data = {
    "Fibrinogen Concentration": [1, 2.7, 5, 10, 2.7, 2.7, 2.7, 2.7],
    "Thrombin Concentration": [0.1, 0.1, 0.1, 0.1, 0.1, 0.25, 0.5, 1],
    "Average Diameter": [178.1, 217.6, 228.2, 284.2, 217.4, 182.6, 168.5, 128.7],
    "Average Pore Size": [8.9, 5.8, 3.1, 1.9, 5.8, 5, 3.2, 2.5],
    "Average % Density": [11.9, 23.7, 44.7, 44.4, 23.7, 29.6, 25.4, 33.2],
    "Average Fiber Length": [9.1, 7.7, 4, 3.3, 7.7, 6.7, 5.6, 3.9],
    "Lag Time": [140, 155, 175, 210, 105, 75, 30, 0],
    "Rate of Formation": [3.4, 6.88, 8.2, 10.2, 9.9, 14.1, 24.5, 33.3],
    "Max Turbidity": [1.85, 5.24, 7.85, 9.35, 5.86, 5.2, 5.13, 4.47]
}

df = pd.DataFrame(data)

# Define the independent variables (Fibrinogen and Thrombin concentrations)
x_fibrinogen = df["Fibrinogen Concentration"].values
x_thrombin = df["Thrombin Concentration"].values

# Iterate through the parameters and perform non-linear regression for each
parameters = df.columns[2:]

for parameter in parameters:
    y_data = df[parameter].values

    # Perform non-linear regression
    params, _ = curve_fit(non_linear_model, x_fibrinogen, y_data)

    # Extract the estimated parameters
    a, b, c = params

    # Calculate R-squared value
    residuals = y_data - non_linear_model(x_fibrinogen, a, b, c)
    ss_residuals = np.sum(residuals**2)
    ss_total = np.sum((y_data - np.mean(y_data))**2)
    r_squared = 1 - (ss_residuals / ss_total)

    # Print the parameter name, equation, and R-squared value
    equation = f"{parameter} = {a:.2f} * exp({b:.2f} * Fibrinogen) * exp({c:.2f} * Thrombin)"
    print(f"{parameter}:")
    print(equation)
    print(f"R-squared: {r_squared:.4f}\n")

